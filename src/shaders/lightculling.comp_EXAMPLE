 #version 450
 #extension GL_EXT_scalar_block_layout: require

 layout(local_size_x =16,local_size_y=16) in;


const int NUM_LIGHTS = 4096;
const int MAX_LIGHTS_PER_TILE = 160;
const int WORK_GROUP_SIZE = 16;
const float SPECULAR_FACTOR = 16.0f;
const float SCREEN_WIDTH = 1920;
const float SCREEN_HEIGHT = 1080;


 struct PointLight {
    vec4 position;
    vec4 color;
    vec4 attenuation; // x constant, y linear, z quadratic
};
layout(set=0, binding=0, rgba16f) uniform readonly image2D gNormalMap;
layout(set=0, binding=1, rgba16f) uniform readonly image2D gAlbedoSpecularMap;
layout(set=0, binding=2, rgba16f) uniform writeonly image2D gOutput;

layout(set=1,binding=0)
uniform Globals {
    vec4 u_view_position;
    mat4 u_view_proj;
    uvec4 lights_num; // X Point lights, Y spot lights
};

layout(std430, set=2,binding=0) buffer PointLights
{ 
   PointLight lights[MAX_POINT_LIGHTS];
}v_pointlights;
shared uint visibleLightIndicies[NUM_LIGHTS];
shared int sVisibleLightCount = 0;

void main()
{
vec2 center = vec2(SCREEN_WIDTH, SCREEN_HEIGHT) / float(2 * WORK_GROUP_SIZE); 
vec2 offset = center - vec2(gl_WorkGroupID.xy);

vec4 column0 = vec4(-gProjectionMatrix[0][0] * center.x, gProjectionMatrix[0][1], offset.x, gProjectionMatrix[0][3]); // (-2 * n' / (r - l) * 80, 0, offset.x, 0)
    vec4 column1 = vec4(gProjectionMatrix[1][0], -gProjectionMatrix[1][1] * center.y, offset.y, gProjectionMatrix[1][3]); // (0, -2 * n' / (t - b) * 45, offset.y, 0)
    vec4 column3 = vec4(gProjectionMatrix[3][0], gProjectionMatrix[3][1], -1.0f, gProjectionMatrix[3][3]); // (0, 0, -1, 0)

vec4 frustumPlanes[4];
    // Left
    frustumPlanes[0] = column3 + column0;
    // Right
    frustumPlanes[1] = column3 - column0;
    // Top
    frustumPlanes[2] = column3 - column1;
    // Bottom
    frustumPlanes[3] = column3 + column1;
    for (int i = 0; i < 4; ++i)
    {
        frustumPlanes[i] /= length(frustumPlanes[i].xyz);
    }
 
    int numThreads = WORK_GROUP_SIZE * WORK_GROUP_SIZE; // 16x16x1 sized thread group; 16x16 tile
    int numPasses = (NUM_LIGHTS + numThreads - 1) / numThreads; // (4096 + 16^2 - 1) / 16^2 = 16

     for (int i = 0; i < numPasses; ++i)
    {
        PointLight pointLight = gPointLights[lightIndex];
        if (sNumVisibleLights < MAX_LIGHTS_PER_TILE)
        {
            bool inFrustum = true;
            for (int j = 3; j >= 0 && inFrustum; --j)
            {
                float distance = dot(frustumPlanes[j], gViewMatrix * vec4(pointLight.position, 1.0f));
                inFrustum = -pointLight.attenuation.x <= distance;
            }
            if (inFrustum)
            {
                int mem = atomicAdd(sNumVisibleLights, 1);
                sVisibleLightIndices[mem] = lightIndex;
            }
        }
    }
    barrier();

    ivec2 texelSpaceTexCoords = ivec2(gl_GlobalInvocationID.xy);
    vec2 texCoords = vec2(texelSpaceTexCoords.x / SCREEN_WIDTH, texelSpaceTexCoords.y / SCREEN_HEIGHT);
    vec4 N = imageLoad(gNormalMap, texelSpaceTexCoords);
    vec3 P = calcWorldPos(texCoords, N.w);
    vec3 V = normalize(gViewPos - P);
    vec4 albedoSpecular = imageLoad(gAlbedoSpecularMap, texelSpaceTexCoords);
 
    vec4 fragColor = vec4(0.1f * albedoSpecular.rgb, 1.0f);
    for (int i = 0; i < sNumVisibleLights; i++)
    {
        fragColor += calcLighting(gPointLights[sVisibleLightIndices[i]], P, N.xyz, V, albedoSpecular);
    }
 
    imageStore(gOutput, texelSpaceTexCoords, fragColor);
}


